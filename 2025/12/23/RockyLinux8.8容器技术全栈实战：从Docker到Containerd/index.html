<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RockyLinux8.8容器技术全栈实战：从Docker到Containerd | Geeeemi's Blog</title><meta name="author" content="Geeeemi"><meta name="copyright" content="Geeeemi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文详细讲解在Rocky Linux 8.8系统上从零搭建完整容器平台的实战过程，涵盖Docker引擎安装、Dockerfile镜像构建、容器资源配额管理、Harbor私有镜像仓库部署、Containerd运行时配置以及Podman容器管理等全栈容器技术，适合运维工程师和DevOps从业者。">
<meta property="og:type" content="article">
<meta property="og:title" content="RockyLinux8.8容器技术全栈实战：从Docker到Containerd">
<meta property="og:url" content="https://geeeemi.github.io/2025/12/23/RockyLinux8.8%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A8%E6%A0%88%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8EDocker%E5%88%B0Containerd/index.html">
<meta property="og:site_name" content="Geeeemi&#39;s Blog">
<meta property="og:description" content="本文详细讲解在Rocky Linux 8.8系统上从零搭建完整容器平台的实战过程，涵盖Docker引擎安装、Dockerfile镜像构建、容器资源配额管理、Harbor私有镜像仓库部署、Containerd运行时配置以及Podman容器管理等全栈容器技术，适合运维工程师和DevOps从业者。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://geeeemi.github.io/img/cover/14.png">
<meta property="article:published_time" content="2025-12-23T12:50:00.000Z">
<meta property="article:modified_time" content="2025-12-23T12:50:00.000Z">
<meta property="article:author" content="Geeeemi">
<meta property="article:tag" content="Containerd">
<meta property="article:tag" content="DevOps">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="Harbor">
<meta property="article:tag" content="Podman">
<meta property="article:tag" content="RockyLinux8.8">
<meta property="article:tag" content="云原生">
<meta property="article:tag" content="容器实战">
<meta property="article:tag" content="容器网络">
<meta property="article:tag" content="私有镜像仓库">
<meta property="article:tag" content="资源配额">
<meta property="article:tag" content="运维指南">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://geeeemi.github.io/img/cover/14.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RockyLinux8.8容器技术全栈实战：从Docker到Containerd",
  "url": "https://geeeemi.github.io/2025/12/23/RockyLinux8.8%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A8%E6%A0%88%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8EDocker%E5%88%B0Containerd/",
  "image": "https://geeeemi.github.io/img/cover/14.png",
  "datePublished": "2025-12-23T12:50:00.000Z",
  "dateModified": "2025-12-23T12:50:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Geeeemi",
      "url": "https://geeeemi.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://geeeemi.github.io/2025/12/23/RockyLinux8.8%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A8%E6%A0%88%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8EDocker%E5%88%B0Containerd/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Geeeemi","link":"链接: ","source":"来源: Geeeemi's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RockyLinux8.8容器技术全栈实战：从Docker到Containerd',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(/img/01.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover/14.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Geeeemi's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">RockyLinux8.8容器技术全栈实战：从Docker到Containerd</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">RockyLinux8.8容器技术全栈实战：从Docker到Containerd</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-23T12:50:00.000Z" title="发表于 2025-12-23 20:50:00">2025-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-23T12:50:00.000Z" title="更新于 2025-12-23 20:50:00">2025-12-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/">容器技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/">运维实战</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/">技术教程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-安装docker容器并配置镜像加速"><a href="#1-安装docker容器并配置镜像加速" class="headerlink" title="1.安装docker容器并配置镜像加速"></a>1.安装docker容器并配置镜像加速</h2><h3 id="1-1-实验环境准备"><a href="#1-1-实验环境准备" class="headerlink" title="1.1 实验环境准备"></a>1.1 实验环境准备</h3><p>​	实验环境：rocky Linux8.8</p>
<p>​	主机名：docker01，docker02</p>
<p>​	主机IP：192.168.10.134（静态）,192.168.10.135（静态）</p>
<p>​	2g内存，2vCPU，100G硬盘</p>
<hr>
<p>​	配置静态IP和主机名 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens160 </span><br><span class="line"><span class="comment"># 内容改为如下</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.10.134</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.10.2</span><br><span class="line">DNS1=192.168.10.2</span><br><span class="line">DNS2=223.5.5.5</span><br><span class="line">DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=eui64</span><br><span class="line">NAME=ens160</span><br><span class="line">UUID=757626b4-14ec-4ec6-a815-bf7059abaf8f</span><br><span class="line">DEVICE=ens160</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 备注</span></span><br><span class="line">BOOTPROTO=static,表示静态配置IP</span><br><span class="line">ONBOOT=<span class="built_in">yes</span>,表示启动机器会自动启动网卡</span><br></pre></td></tr></table></figure>

<p>​		网络配置文件的生效方式：重载网卡，重载网卡之前一定要重新载入配置文件，否则不会立即生效。该命令仅针对与单个网卡</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nmcli connection reload</span><br></pre></td></tr></table></figure>

<p>​	开启网卡（单独该网卡）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nmcli c up ens160</span><br></pre></td></tr></table></figure>

<p>​	安装如下软件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lrzsz文件传输工具，vim-enhanced增强版vim</span></span><br><span class="line">[root@localhost ~]# yum install lrzsz vim-enhanced -y</span><br></pre></td></tr></table></figure>

<p>​	配置主机名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl set-hostname docker01</span><br><span class="line">[root@localhost ~]# bash</span><br></pre></td></tr></table></figure>

<hr>
<p>​	关闭Selinux、停掉防火墙</p>
<p>​	学习和测试Docker时临时关闭SELinux和防火墙是为了避免权限和网络冲突，方便快速上手，但生产环境必须保持开启并正确配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：修改selinux配置文件之后，重启linux机器，selinux才能永久生效</span></span><br><span class="line">[root@docker01 ~]# reboot</span><br><span class="line">[root@docker01 ~]# getenforce 	<span class="comment">#查看selinux是否关闭</span></span><br><span class="line">Disabled</span><br><span class="line"><span class="comment"># 显示Disabled说明selinux关闭成功</span></span><br><span class="line"></span><br><span class="line">[root@docker01 ~]# systemctl stop firewalld &amp;&amp; systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">Removed /etc/systemd/system/multi-user.target.wants/firewalld.service.</span><br><span class="line">Removed /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span><br></pre></td></tr></table></figure>

<hr>
<p>​	配置时间同步：</p>
<p>​	基于chrony配置服务器时间跟网络时间同步</p>
<p>​	以前我们使用ntpdate来同步系统时间，但是，ntpdate是立即同步，在生产环境下，系统时间大范围的跳动，是非	常严重的事件</p>
<p>​	chrony是网络事件协议(NTP)的另一种实现，与网络事件协议后台程序(ntpd)不同，他可以更快且更准确同步系统 	时钟。两个主要程序：<strong>chronyd</strong>和<strong>chronyc</strong></p>
<p>​	chronyd：后台运行的守护进程，用于调整内核中运行的系统时钟和时钟服务器同步 ，他确定计算机增减时间的	比率，并对此进行补偿。</p>
<p>​	chronyc：命令行用户工具，用于监控性能并进行多样化的配置，他在chronyd实例控制的计算机上工作</p>
<p>​	服务unit文件：&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;chronyd.service</p>
<p>​	监听端口：323&#x2F;upd，123&#x2F;udp</p>
<p>​	配置文件：&#x2F;etc&#x2F;chrony.conf</p>
<p>​	ntpdate和chrony是服务器时间同步的主要工具，两者的主要区别就是：</p>
<p>​		1、执行ntpdate后，时间是立即修改的，中间会出现时间断档。</p>
<p>​		2、而执行chrony后，时间也会修正，但是是缓慢将时间追回，并不会断档。</p>
<p>​	在docker01上执行如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始安装chrony服务</span></span><br><span class="line">[root@docker01 ~]# yum -y install chrony	</span><br><span class="line">[root@docker01 ~]# systemctl  <span class="built_in">enable</span> chronyd --now		<span class="comment">#设置chrony开机启动并立即启动 chronyd服务同步网络时间</span></span><br></pre></td></tr></table></figure>

<p>​	编辑chronyd配置文件，使用中国的时间服务器同步时间，速度更快</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# vim /etc/chrony.conf </span><br><span class="line"><span class="comment"># 文件最后增加如下内容</span></span><br><span class="line">server ntp1.aliyun.com iburst</span><br><span class="line">server ntp2.aliyun.com iburst</span><br><span class="line">server ntp1.tencent.com iburst</span><br><span class="line">server ntp2.tencent.com iburst</span><br><span class="line"></span><br><span class="line">[root@docker01 ~]# systemctl restart chronyd</span><br><span class="line">[root@docker01 ~]# <span class="built_in">date</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	写一个计划任务，定时同步时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# crontab -e</span><br><span class="line">* * * * * /usr/bin/systemctl restart chronyd</span><br><span class="line"></span><br><span class="line">[root@docker01 ~]# systemctl restart crond</span><br></pre></td></tr></table></figure>

<hr>
<p>​	开启包转发功能和修改内核参数</p>
<p>​	开启包转发功能和修改内核参数是为了让容器能够正常进行网络通信，解决容器间及容器与外部网络的数据包转发问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# modprobe br_netfilter </span><br><span class="line">[root@docker01 ~]# <span class="built_in">cat</span> &gt; /etc/sysctl.d/docker.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">[root@docker01 ~]# sysctl -p /etc/sysctl.d/docker.conf </span><br></pre></td></tr></table></figure>

<p>​	备注，内核参数相关说明：</p>
<p>​	1、net.bridge.bridge-nf-call-ip6tables &#x3D; 1：该参数启用了桥接网络设备(bridge)在IPV6包进行iptables规则过滤   	时，通过netfilter模块将数据包传递给iptables处理。这参数通常用于虚拟化环境，如docker等，以支持IPV6流量	的转发和安全过滤，如果不开启该参数，则在桥接设备的IPV6流量无法进行iptables规则过滤。</p>
<p>​	2.net.bridge.bridge-nf-call-iptables &#x3D; 1：该参数启用了桥接网络设备(bridge)在IPV4包进行iptables规则过滤时，	通过netfilter模块将数据包传递给iptables处理。这参数通常用于虚拟化环境，如docker等，以支持IPV4流量的转	发和安全过滤，如果不开启该参数，则在桥接设备的IPV6流量无法进行iptables规则过滤。</p>
<p>​	3.net.ipv4.ip_forward &#x3D; 1：该参数启用了linux操作系统的IP转发功能，允许路由器讲接收到的数据包转发到其他	网络，这个参数通常同于构建网络拓扑，如在一个局域网内部部署多台主机并让它们可以访问外部互联网，如果	不启用该参数，则linux系统默认不会转发IP数据包。</p>
<hr>
<p>​	在线安装docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# yum install -y  yum-utils</span><br><span class="line">[root@docker01 ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>​	开始安装docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]#  yum install -y wget net-tools nfs-utils gcc gcc-c++ make cmake libxml2-devel openssl-devel curl curl-devel unzip <span class="built_in">sudo</span> libaio-devel ncurses-devel autoconf automake zlib-devel epel-release openssh-server socat ipvsadm conntrack-tools</span><br><span class="line">[root@docker01 ~]#  yum install -y containerd.io-1.6.31-3.1.el8</span><br><span class="line">[root@docker01 ~]#  yum install -y docker-ce</span><br><span class="line"><span class="comment"># 备注yum install安装软件包 ，加参数--allowerasing可以替换掉冲突的软件包，这上面我是拆开来安装的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动docker服务</span></span><br><span class="line">[root@docker01 ~]# systemctl start docker &amp;&amp; systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker版本信息</span></span><br><span class="line">[root@docker01 ~]# docker -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker状态</span></span><br><span class="line">[root@docker01 ~]# systemctl status docker</span><br><span class="line"><span class="comment"># 如果是running说明正常启动了</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="1-2-docker基本用法-操作镜像"><a href="#1-2-docker基本用法-操作镜像" class="headerlink" title="1.2 docker基本用法-操作镜像"></a>1.2 docker基本用法-操作镜像</h3><p>​	搜索镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker search centos		<span class="comment"># 默认docker hub搜索，可能会存在更换源依旧不能搜索的情况</span></span><br></pre></td></tr></table></figure>

<p>​	访问<a target="_blank" rel="noopener" href="http://registry.hub.docker.com/">docker hub</a></p>
<p>​	从docker hub下载镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">Error response from daemon: Get <span class="string">&quot;https://registry-1.docker.io/v2/&quot;</span>: net/http: request canceled <span class="keyword">while</span> waiting <span class="keyword">for</span> connection (Client.Timeout exceeded <span class="keyword">while</span> awaiting headers)</span><br><span class="line"><span class="comment"># 报错了，网络问题，无法连接到docker hub下载镜像。</span></span><br></pre></td></tr></table></figure>

<p>​	解决办法：可以换种方法下载镜像</p>
<p>​	方法1：配置镜像加速器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或覆盖配置文件</span></span><br><span class="line">[root@docker01 ~]# <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://docker-0.unsee.tech&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker-cf.registry.cyou&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.1panel.live&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker服务使配置生效</span></span><br><span class="line">[root@docker01 ~]# <span class="built_in">sudo</span> systemctl daemon-reload &amp;&amp; <span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker无法正常拉去，怀疑是源的问题，换了源，问题依旧，怀疑是网络的问题，ping不通114.114.114.114,怀疑是家庭网络的问题，开手机热点解决，问题依旧，是该ip运维人员开启了ICMP策略，经过排查，依旧是源的问题，经过上网寻找可靠源，解决了 </span></span><br></pre></td></tr></table></figure>

<p>​	方法 2：把之前下载好的镜像通过<strong>docker load -i</strong>解压出来：</p>
<p>​	把centos.tar.gz、nginx.tar.gz镜像包上传到本机的root目录下，通过<strong>docker load -i</strong>解压出来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把docker保存的文件解压出来</span></span><br><span class="line">[root@docker01 ~]# docker load -i /root/centos.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：把镜像打包成离线文件</span></span><br><span class="line">[root@docker01 ~]# docker save -o centos.tar.gz centos</span><br></pre></td></tr></table></figure>

<p>​	删除镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker rmi -f &lt;镜像名称&gt;:[tag]</span><br></pre></td></tr></table></figure>

<p>​	镜像打标签，重新取个名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker tag centos:latest centos:v1</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="1-3-通过docker部署应用"><a href="#1-3-通过docker部署应用" class="headerlink" title="1.3 通过docker部署应用"></a>1.3 通过docker部署应用</h3><p>​	一些常用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 镜像启动容器</span></span><br><span class="line">[root@docker01 ~]# docker run -d -p 80:80 nginx </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker容器的IP</span></span><br><span class="line">[root@docker01 ~]# docker inspect &lt;容器<span class="built_in">id</span> | 容器的名字&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给容器起一个名字</span></span><br><span class="line">[root@docker01 ~]# docker run --name nginxtest -d -p 200:80 nginx</span><br><span class="line"><span class="comment"># --name后面：指的是容器的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停掉docker容器</span></span><br><span class="line">[root@docker01 ~]# docker stop 容器名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有，包括停止的容器</span></span><br><span class="line">[root@docker01 ~]# docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志</span></span><br><span class="line">[root@docker01 ~]# docker <span class="built_in">log</span> 容器名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">[root@docker01 ~]# docker start 容器名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器改名字</span></span><br><span class="line">[root@docker01 ~]# docker rename old_name new_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问正在运行的容器</span></span><br><span class="line">[root@docker01 ~]# docker <span class="built_in">exec</span> -it &lt;container <span class="built_in">id</span> | name&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看正在运行的容器id</span></span><br><span class="line">[root@docker01 ~]# docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">[root@docker01 ~]# docker <span class="built_in">exec</span> -it</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除镜像</span></span><br><span class="line">[root@docker01 ~]# docker rmi -f 镜像名字、镜像ID  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像</span></span><br><span class="line">[root@docker01 ~]# docker images</span><br></pre></td></tr></table></figure>

<p>​	网卡veth是一个中间件转发网络的，负责连接服务器和docker访问的中间件</p>
<hr>
<h3 id="1-4基于dockerfile构建镜像"><a href="#1-4基于dockerfile构建镜像" class="headerlink" title="1.4基于dockerfile构建镜像"></a>1.4基于dockerfile构建镜像</h3><p>​	做nginx镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# <span class="built_in">mkdir</span> nginx</span><br><span class="line">[root@docker01 ~]# <span class="built_in">cd</span> nginx/</span><br><span class="line">[root@docker01 nginx]# vim dockerfile</span><br><span class="line"><span class="comment"># 基于官方镜像来构造docker镜像</span></span><br><span class="line">FROM rockylinux:8.8</span><br><span class="line"><span class="comment"># 作者信息，可选</span></span><br><span class="line">LABEL maintainer=<span class="string">&quot;pod&lt;pod@example.com&gt;&quot;</span></span><br><span class="line"><span class="comment"># 使用sed命令的选项来执行文本编辑操作</span></span><br><span class="line">RUN sed -e <span class="string">&#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;</span> \</span><br><span class="line">    -e <span class="string">&#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27;</span> \</span><br><span class="line">    -i.bak /etc/yum.repos.d/*.repo</span><br><span class="line"><span class="comment"># 下面这是在docker装东西</span></span><br><span class="line">RUN yum install wget -y &amp;&amp; \</span><br><span class="line">    yum install nginx -y &amp;&amp; \</span><br><span class="line">    yum clean all</span><br><span class="line"><span class="comment"># /usr/share/nginx/html/目录下的index.html需要自己创建COPY是直接拷贝,ADD能自动解压tar.gz文件并拷贝，ENV设置环境变量</span></span><br><span class="line">COPY index.html /usr/share/nginx/html/.</span><br><span class="line"><span class="comment"># 端口不能写范围（能生效不能访问范围内的所有端口），但可以分开写 80 81 82</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"><span class="comment"># 自动在容器执行[&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]命令，保持始终活跃状态，非常重要！！！ ENTRYPOINT和CMD命令完全一样，</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/usr/sbin/nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#构建镜像，.代表在当前目录下构建</span></span><br><span class="line">[root@docker01 nginx]# docker build -t=<span class="string">&quot;docker01/nginx:v1&quot;</span> .  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动创建的这个容器，80指的是容器内的端口</span></span><br><span class="line">[root@docker01 nginx]# docker run -d -p 80 --name html1 docker01/nginx:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动创建的这个容器，80指的是容器内的端口,这里的3000是固定端口，</span></span><br><span class="line">[root@docker01 nginx]# docker run -d -p 3000:80 --name html2 docker01/nginx:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动创建的这个容器，这里的-P是随机生成一个端口与dockerfile文件内的EXPOSE端口绑定</span></span><br><span class="line">[root@docker01 nginx]# docker run -d -P --name html3 docker01/nginx:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器是否启动</span></span><br><span class="line">[root@docker01 nginx]# docker ps</span><br></pre></td></tr></table></figure>

<p>​	做ubuntu镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# <span class="built_in">mkdir</span> ubuntu</span><br><span class="line">[root@docker01 ~]# <span class="built_in">cd</span> ubuntu/</span><br><span class="line">[root@docker01 ubuntu]# vim dockerfile</span><br><span class="line">FROM ubuntu</span><br><span class="line">MAINTAINER Pod</span><br><span class="line">RUN <span class="built_in">echo</span> hello1 &gt; test1.txt</span><br><span class="line">RUN <span class="built_in">echo</span> hello2 &gt; /test2.txt</span><br><span class="line"><span class="comment"># ENTRYPOINT和CMD混着用，ENTRYPOINT指的是命令，CMD指的是参数，后面做K8S需要用到，ENTRYPOINT优先级高于CMD</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;echo&quot;</span>]</span><br><span class="line">CMD [<span class="string">&quot;defaultvalue&quot;</span>]</span><br><span class="line">CMD [<span class="string">&quot;helllo&quot;</span>]</span><br><span class="line"><span class="comment"># 只会在最后一个生效 </span></span><br><span class="line">CMD [<span class="string">&quot;Hello&quot;</span>]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2、docker实战-dockerfile构建企业级镜像和资源配额"><a href="#2、docker实战-dockerfile构建企业级镜像和资源配额" class="headerlink" title="2、docker实战-dockerfile构建企业级镜像和资源配额"></a>2、docker实战-dockerfile构建企业级镜像和资源配额</h2><h3 id="实战1：docker构建nginx镜像—部署nginx静态网站"><a href="#实战1：docker构建nginx镜像—部署nginx静态网站" class="headerlink" title="实战1：docker构建nginx镜像—部署nginx静态网站"></a>实战1：docker构建nginx镜像—部署nginx静态网站</h3><p>​	<a target="_blank" rel="noopener" href="https://nginx.org/download/nginx-1.15.2.tar.gz">nginx下载</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建工作目录，提前下载nginx-1.15.2.tar.gz，并上传到nginx1/下(源码安装)</span></span><br><span class="line">[root@docker01 ~]# <span class="built_in">mkdir</span> /root/nginx1</span><br><span class="line">[root@docker01 ~]# <span class="built_in">cd</span> nginx1/</span><br><span class="line">[root@docker01 nginx1]# vim run.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br><span class="line"></span><br><span class="line">[root@docker01 nginx1]# vim dockerfile</span><br><span class="line">FROM rockylinux:8.8</span><br><span class="line">LABEL maintainer=<span class="string">&quot;pod&lt;pod@example.com&gt;&quot;</span></span><br><span class="line">RUN sed -e <span class="string">&#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;</span> \</span><br><span class="line">    -e <span class="string">&#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27;</span> \</span><br><span class="line">    -i.bak /etc/yum.repos.d/*.repo</span><br><span class="line">RUN yum -y install gcc make pcre-devel zlib-devel tar zlib</span><br><span class="line">ADD nginx-1.15.2.tar.gz /usr/src/</span><br><span class="line">RUN <span class="built_in">cd</span> /usr/src/nginx-1.15.2 \</span><br><span class="line">	&amp;&amp; <span class="built_in">mkdir</span> /usr/local/nginx \</span><br><span class="line">    &amp;&amp; ./configure --prefix=/usr/local/nginx \</span><br><span class="line">    &amp;&amp; make \</span><br><span class="line">    &amp;&amp; make install \</span><br><span class="line">    &amp;&amp; <span class="built_in">ln</span> -s /usr/local/nginx/sbin/nginx /usr/local/sbin/nginx \</span><br><span class="line">    &amp;&amp; nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;daemon off;&quot;</span> &gt;&gt; /usr/local/nginx/conf/nginx.conf</span><br><span class="line">COPY run.sh /run.sh</span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /run.sh</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [<span class="string">&quot;/run.sh&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">[root@docker01 nginx]# docker build -t=<span class="string">&quot;docker01/nginx:v2&quot;</span> .  </span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">[root@docker01 nginx1]# docker run -d -P --name html docker01/nginx:v2</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="实战2：docker构建tomcat镜像"><a href="#实战2：docker构建tomcat镜像" class="headerlink" title="实战2：docker构建tomcat镜像"></a>实战2：docker构建tomcat镜像</h3><p>​	<a target="_blank" rel="noopener" href="https://archive.apache.org/dist/tomcat/tomcat-8/v8.0.26/bin/apache-tomcat-8.0.26.tar.gz">apache-tomcat-8.0.26.tar.gz 下载</a></p>
<p>​	<a target="_blank" rel="noopener" href="https://pan.quark.cn/s/8a53b1e26283">jdk-8u45-linux-x64.rpm 下载</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建工作目录，提前下载apache-tomcat-8.0.26.tar.gz，并上传到nginx1/下(源码安装)</span></span><br><span class="line">[root@docker01 ~]# <span class="built_in">mkdir</span> tomcat</span><br><span class="line">[root@docker01 ~]# <span class="built_in">cd</span> tomcat/</span><br><span class="line">[root@docker01 tomcat]# vim dockerfile</span><br><span class="line">FROM rockylinux:8.8</span><br><span class="line">LABEL maintainer=<span class="string">&quot;pod&lt;pod@example.com&gt;&quot;</span></span><br><span class="line">RUN sed -e <span class="string">&#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;</span> -e <span class="string">&#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=http://mirrors.aliyun.com/rockylinux|g&#x27;</span> -i.bak /etc/yum.repos.d/*.repo</span><br><span class="line">COPY jdk-8u45-linux-x64.rpm /usr/local/</span><br><span class="line">ADD apache-tomcat-8.0.26.tar.gz /usr/local/</span><br><span class="line">RUN <span class="built_in">cd</span> /usr/local &amp;&amp; yum install jdk-8u45-linux-x64.rpm -y</span><br><span class="line">RUN <span class="built_in">mv</span> /usr/local/apache-tomcat-8.0.26 /usr/local/tomcat8</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/usr/local/tomcat8/bin/startup.sh &amp;&amp; tail -F /usr/local/tomcat8/logs/catalina.out&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">[root@docker01 nginx]# docker build -t=<span class="string">&quot;docker01/tomcat8:v1&quot;</span> .  </span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">[root@docker01 nginx1]# docker run -d -P --name tomcat8 docker01/tomcat8:v1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="实战3：docker构建apache镜像"><a href="#实战3：docker构建apache镜像" class="headerlink" title="实战3：docker构建apache镜像"></a>实战3：docker构建apache镜像</h3><p>​	httpd是Apache Web服务器的标准守护进程名称，也称为Apache HTTP Server，在linux中，通常使用httpd作为Apache Web服务器的服务名称</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建工作目录</span></span><br><span class="line">[root@docker01 ~]# <span class="built_in">mkdir</span> /root/apache</span><br><span class="line">[root@docker01 ~]# <span class="built_in">cd</span> apache/</span><br><span class="line">[root@docker01 apache]# vim run.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf /run/httpd/*</span><br><span class="line"><span class="comment"># 启动容器时启动服务</span></span><br><span class="line"><span class="built_in">exec</span> /usr/sbin/apachectl -D FOREGROUND</span><br><span class="line"></span><br><span class="line">[root@docker01 apache]# vim index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">    &lt;title&gt;站点运行正常！&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body &#123;</span><br><span class="line">            font-family: Arial, sans-serif;</span><br><span class="line">            text-align: center;</span><br><span class="line">            padding-top: 50px;</span><br><span class="line">            background: linear-gradient(to right, <span class="comment">#8e9eab, #eef2f3);</span></span><br><span class="line">        &#125;</span><br><span class="line">        h1 &#123; color: <span class="comment">#2c3e50; &#125;</span></span><br><span class="line">        .box &#123;</span><br><span class="line">            width: 60%;</span><br><span class="line">            margin: 20px auto;</span><br><span class="line">            padding: 30px;</span><br><span class="line">            background: white;</span><br><span class="line">            border-radius: 10px;</span><br><span class="line">            box-shadow: 0 5px 15px rgba(0,0,0,0.1);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;✅ 恭喜！&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;你的网站已成功运行。&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;这是一个用于功能测试的极简页面。&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;服务器时间：&lt;span <span class="built_in">id</span>=<span class="string">&quot;time&quot;</span>&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;p style=<span class="string">&quot;color:#7f8c8d; font-size:0.9em;&quot;</span>&gt;页面源码仅 20 行，无任何后端依赖。&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        document.getElementById(<span class="string">&#x27;time&#x27;</span>).textContent = new Date().toLocaleString();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">[root@docker01 tomcat]# vim dockerfile</span><br><span class="line">FROM rockylinux:8.8</span><br><span class="line">LABEL maintainer=<span class="string">&quot;pod&lt;pod@example.com&gt;&quot;</span></span><br><span class="line">RUN sed -e <span class="string">&#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;</span> -e <span class="string">&#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=http://mirrors.aliyun.com/rockylinux|g&#x27;</span> -i.bak /etc/yum.repos.d/*.repo</span><br><span class="line">RUN yum -y install httpd</span><br><span class="line">ADD index.html /var/www/html</span><br><span class="line">ADD run.sh /run.sh</span><br><span class="line">RUN <span class="built_in">chmod</span> 755 /run.sh</span><br><span class="line">EXPOSE 80</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/run.sh&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">[root@docker01 apache]# docker build -t docker01/apache:v1 .</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">[root@docker01 nginx1]# docker run -d -P --name apache docker01/apache:v1</span><br></pre></td></tr></table></figure>

<p>​	备注</p>
<p>​	exec &#x2F;usr&#x2F;sbin&#x2F;apachectl -D FOREGROUND参数说明：这是一个启动Apache Web服务器的命令，其中&#x2F;usr.sbin&#x2F;apachectl是Apache Web服务器的启动脚本，-D FOREGROUND是一个 参数，用于指定服务器在前台运行。更加具体的说，-D FOREGROUND参数告诉Apache Web服务器在启动后在前台运行。</p>
<p>​	1、exec：exec的作用是将&#x2F;usr&#x2F;sbin&#x2F;apachectl -D FOREGROUND 命令替换成当前进程，并使Apache Web服务器成为docker容器中唯一运行的进程。</p>
<p>​	2、&#x2F;usr&#x2F;sbin&#x2F;apachectl：表示要执行的命令，即apachectl工具的路径。</p>
<p>​	3、-D FOREGROUND：表示让Apache HTTP服务器在前台运行，并将日志输出到标准输出中，这样可以方便查看服务器日志信息，以及在容器内部进行调试和监控。</p>
<hr>
<h3 id="2-1-docker运行容器限制CPU"><a href="#2-1-docker运行容器限制CPU" class="headerlink" title="2.1 docker运行容器限制CPU"></a>2.1 docker运行容器限制CPU</h3><p>​	docker通过linux内核的cgroup(控制组)功能来实现容器的资源配额和限制，cgroup可以对容器中运行的进程进行分组，并为每个分组分配特定的资源配额和限制。</p>
<p>​	cgroup(控制组)是linux内核提供的一种机制，可以对一组进程或线程进行资源限制、优先级控制、账户分配等操作。通过cgroup可以对CPU、内存、磁盘IO、网络带宽等资源进行限制和管理。例如，可以将一组进程或线程归为一个cgroup，并对该cgroup中的进程或线程设置CPU配额、内存限制等，从而实现对系统资源的精细控制。cgroup还可以进行账户分配，允许不同的用户或组使用系统资源的不同份额。</p>
<hr>
<p>​	在docker中，CPU份额是一种CPU资源管理机制，可以用于控制docker容器可以使用的CPU资源数量，它允许你将CPU资源按比例分配给不同的容器，以确保在共享主机的情况下，每个容器都可以获得足够的CPU时间。</p>
<p>​	docker使用Linux内核提供cgroups来管理CPU资源。在cgroups中，可以使用cpu.shares参数来分配CPU资源份额。该参数的值是一个<strong>相对权重，它定义了一个容器和其他容器之间分配CPU时间的相对比例</strong>。</p>
<p>​	例如，如果将一个容器的cpu.shares参数设置为1024，而将另一个容器的cpu.shares参数设置为512，这两个容器跑在一个CPU，第一个容器将获得比第二个容器更多的CPU时间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linux查看cpu命令 </span></span><br><span class="line">[root@docker01 ~]# top</span><br></pre></td></tr></table></figure>

<p>​	可以在docker中使用 –cpu-shares 参数来设置CPU资源份额，例如，以下命令将创建一个名为my-nginx的容器，并将CPU资源份额设置为512。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -it --name my-nginx --cpu-shares=512 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">[root@docker01 ~]# docker run -it --cpu-shares=512 rockylinux:8.8 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看CPU份额，默认份额1024</span></span><br><span class="line">[root@609bf9ef9eac /]# <span class="built_in">cat</span> sys/fs/cgroup/cpu/cpu.shares</span><br><span class="line">512</span><br></pre></td></tr></table></figure>

<p>​	总结：默认每个docker容器的CPU份额都是1024，如果多个容器在同一个CPU上，容器的CPU份额才能体现出来。</p>
<p>​	假如你的主机只有一个CPU核心，而且两个docker的容器需要运行，如果为这两个容器分配不同的CPU份额值，将会有以下几种不同的情况：</p>
<p>​	1、容器A的CPU份额值是512，容器B的CPU范围值是256，这意味着容器A将获得主机CPU时间片的2&#x2F;3，容器B将获得1&#x2F;3。<strong>这种情况下，容器A可能会运行得更快，并且可能比容器B更快的响应请求，因为它获得了更多的CPU时间片</strong>。</p>
<p>​	2、容器A的CPU份额值是256，容器B的CPU范围值是512，这意味着容器A将获得主机CPU时间片的1&#x2F;3，容器B将获得2&#x2F;3。<strong>这种情况下，容器B可能会运行得更快，并且可能比容器A更快的响应请求，因为它获得了更多的CPU时间片</strong>。</p>
<p>​	3、容器A和容器B的CPU份额值都是512，这意味着他们将平均获得主机CPU时间片的一半。在这种情况下，两个容器的可能性可能会非常相似，因为他们获得了CPU时间片相等。</p>
<hr>
<p>限制docker运行在特定的CPU和内存节点上，参数**–cpuset-cpus 和–cpuset-mems**</p>
<p>docker可以使用–cpuset-cpus 和–cpuset-mems参数来控制容器CPU内核和内存节点，这对于多核CPU的服务器特别有用，可以对需要高性能计算的容器进行性能最优的配置。</p>
<p>​	1、–cpuset-cpus ：它用于指定容器可以使用的CPU节点列表，以逗号分隔。例如将其设为–cpuset-cpus&#x3D;0,1，则表示该容器可以在CPU节点0和1上运行。这有助于将容器限制在特定的CPU上运行，以获得更好的性能或避免与其他容器共享CPU。</p>
<p>​	2、–cpuset-mems：它用于指定容器可以使用的内存节点列表，以逗号分格。例如，如果将其设置为–cpuset-mems&#x3D;0,1，则表示该容器可以在内存节点0和1上运行。这有助于将容器限制在特定的内存节点上运行，以控制容器对内系统内存的使用情况。</p>
<p>​	CPU限制	cpu参数混合使用**使用场景</p>
<p>​	–cpuset-cpus 和–cpuset-mems 一起使用</p>
<p>​	例1：创建两个容器实例docker10和docker20，让docker10和docker20只运行在cpu0和cpu1上，最终测试一下docker10和docker20使用CPU的百分比（docker10容器使用512份额CPU，docker20容器使用1024份额CPU）</p>
<p>​	运行两个容器实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定docker10只能在cpu0和cpu1上运行，而且docker10使用CPU的份额为512，-d指的是在后台运行</span></span><br><span class="line">[root@docker01 ~]# docker run -itd --name docker10 --cpuset-cpus 0,1 --cpu-shares 512 rockylinux:8.8 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定docker20只能在cpu0和cpu1上运行，而且docker20使用CPU的份额为1024，-d指的是在后台运行</span></span><br><span class="line">[root@docker01 ~]# docker run -itd --name docker20 --cpuset-cpus 0,1 --cpu-shares 1024 rockylinux:8.8 /bin/bash</span><br></pre></td></tr></table></figure>

<p>​	上面的命令中，–cpuset-cpus指定了容器使用的CPU，-cpu-shares指定了容器CPU分配的权重，docker10使用CPU 0,1，权重为512，docker20使用CPU 0,1，权重为1024。这样的话，当CPU资源不足时，docker讲按权重分配CPU时间片，第二个容器获得的CPU时间片应该比第一个容器多一些，响应速度也更快</p>
<hr>
<p>​	测试1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入docker10，使用stress测试进程是不是只在cpu0,1上运行</span></span><br><span class="line">[root@docker01 ~]# yum install -y stress</span><br><span class="line">[root@docker01 ~]# docker <span class="built_in">cp</span> /usr/bin/stress docker10:/usr/bin/</span><br><span class="line">[root@docker01 ~]# docker <span class="built_in">exec</span> -it docker10 /bin/bash</span><br><span class="line">[root@50121a0676b6 /]# stress -c 2 -v -t 10m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	备注：stress参数说明</p>
<p>​	-c 2：使用两个CPU核心进行压力测试。</p>
<p>​	-v：打印详细输出，包括运行时间、平均负载等信息。</p>
<p>​	-t 10m：运行时长为10min。</p>
<p>​	测试2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入docker20，使用stress测试进程是不是只在cpu0,1上运行</span></span><br><span class="line">[root@docker01 ~]# docker <span class="built_in">cp</span> /usr/bin/stress docker20:/usr/bin/</span><br><span class="line">[root@docker01 ~]# docker <span class="built_in">exec</span> -it docker20 /bin/bash</span><br><span class="line">[root@0f3d26d42acb /]# stress -c 2 -v -t 10m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>了解CPU周期控制</p>
<p>​	docker提供了–cpu-period、–cpu-quota两个参数控制容器可以分配到的CPU时间。</p>
<p>​		–cpu-period：参数定义CPU周期长度，单位为微秒，它指定了CPU资源在多长时间内可以被容器使用，默认值是0.1s，例如，设置–cpu-period&#x3D;100000意味着容器可以每100ms使用一次CPU。最小值为1000微秒，最大值为10^6微秒，默认为0.1s。</p>
<p>​		–cpu-quota：参数定义CPU资源使用的时间配额，单位为微秒，它指定容器可以在每个CPU周期内使用CPU时间的最大值，例如设置–cpu-quota&#x3D;50000意味着容器每100ms可以最多使用50ms的CPU时间。默认值为-1，表示不做控制。</p>
<p>​	这两个参数的具体使用场景如下</p>
<p>​	1、CPU资源分配：当多个容器运行在同一主机时，–cpu-period和–cpu-quota参数可以用于限制容器使用的CPU资源，这样可以确保每个容器都能获得足够的CPU时间，并避免某个容器占用过多的CPU资源。</p>
<p>​	2、应用程序性能测试：–cpu-period和–cpu-quota参数可以用于测试应用程序在不同CPU限制下的性能。例如，可以通过逐步减少–cpu-quota参数的值，测试应用程序在不同CPU限制下的响应时间和处理能力。</p>
<hr>
<p>​	例1：设置docker实例每秒只能使用单个CPU的0.2s时间，可以将cpu-period设置为1000000(即1s)，cpu-quota设置为200000(0.2s)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 演示 --cpu-period和--cpu-quota 参数的使用效果</span></span><br><span class="line">[root@docker01 ~]# <span class="built_in">mkdir</span> python</span><br><span class="line">[root@docker01 ~]# <span class="built_in">cd</span> python/</span><br><span class="line">[root@docker01 python]# yum install python3 -y</span><br><span class="line">[root@docker01 python]# vim calculate_sum.py</span><br><span class="line">total = 0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,1000000000000000001):</span><br><span class="line">    total += 1</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;The sum of all integers from 1 to 10000 is: &#123;total&#125;&quot;</span>)</span><br><span class="line">   </span><br><span class="line">[root@docker01 python]# vim dockerfile</span><br><span class="line">FROM python:3.9-slim-buster</span><br><span class="line">COPY calculate_sum.py /</span><br><span class="line">CMD [<span class="string">&quot;python&quot;</span>,<span class="string">&quot;/calculate_sum.py&quot;</span>]</span><br><span class="line"></span><br><span class="line">[root@docker01 python]# docker build -t my-image .</span><br><span class="line">[root@docker01 python]# docker run --name cal -it --cpuset-cpus 0 --cpu-period 1000000 --cpu-quota 200000 my-image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看CPU运行占用情况</span></span><br><span class="line">[root@docker01 ~]# docker stats</span><br></pre></td></tr></table></figure>

<p>​	这个命令是在docker中运行一个容器my-image，计算大数字，并设置CPU周期为1000000微秒(即1秒)，CPU配额为200000微秒(即0.2秒)。这意味着该容器在任意1秒钟的时间内只能够使用0.2秒的CPU时间。如果在一个单核CPU的系统上运行这个容器，并将CPU配额为0.2秒，那么该容器的CPU使用率最大只能达到20%，因为在一个单核CPU的系统上，一个CPU核心的最大使用率是100%，如果容器只能使用0.2秒的CPU时间，那么在一秒钟内，它的CPU最使用率最大只能达到20%。</p>
<p>​	备注：docker容器如果制定了–cpu-period或者–cpuset-cpus怎么解除限制？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># update动态调整</span></span><br><span class="line">[root@docker01 python]# docker update --cpuset-cpus=0-3 my-containet</span><br></pre></td></tr></table></figure>

<hr>
<p>​	docker容器实例运行结束后自动释放资源</p>
<p>​	应用场景，在某些环境下，可能需要大量新建的docker的实例，然后仅仅运行几秒钟或几分钟，然后就彻底删除，如运行单元测试或测试弹性云计算。</p>
<p>​	例，阿里云要模拟双11的压力，需要快速创建1万个docker实例，每个docker实例中都运行ab命令，拼命访问tmall.com首页，运行1个小时，1小时后自动删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当容器命令结束后，自动删除容器，自动释放资源</span></span><br><span class="line">[root@docker01 python]# docker run --<span class="built_in">help</span> | grep <span class="built_in">rm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如</span></span><br><span class="line">[root@docker01 python]# docker run -it --<span class="built_in">rm</span> --name mk rockylinux:8.8 <span class="built_in">sleep</span> 10</span><br><span class="line"><span class="comment"># 在物理机查看，等待10s后就自动删除了</span></span><br><span class="line">[root@docker01 ~]# docker ps -a | grep mk</span><br></pre></td></tr></table></figure>



<hr>
<p>​	什么叫做多内存，如何实现？</p>
<p>​	在Linux上，可以使用NUMA架构来实现多个内存节点。NUMA是一种计算机架构，它将多个CPU和内存节点组合在一起，以提高系统的性能和可伸缩性。在NUMA架构中，每个CPU可以访问本地内存节点和远程内存节点，本地内存访问速度较快，远程内存访问速度较慢。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看服务器是否为多内存，需下载lshw</span></span><br><span class="line">[root@docker01 nginx1]# yum install lshw -y</span><br><span class="line">[root@docker01 nginx1]# lshw -class memory |grep memory</span><br><span class="line">  *-memory</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="2-2docker运行容器限制内存"><a href="#2-2docker运行容器限制内存" class="headerlink" title="2.2	docker运行容器限制内存"></a>2.2	docker运行容器限制内存</h3><p>​	docker提供参数-m，–memory&#x3D;””限制容器的内存使用量。</p>
<p>​	例1：允许容器使用的内存上限为256M</p>
<p>​	1MB&#x3D;1,048,576字节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许容器使用的内存上限为256M</span></span><br><span class="line">[root@docker01 ~]# docker run --name m1 -itd -m 256m rockylinux:8.8</span><br><span class="line">[root@docker01 ~]# docker <span class="built_in">cp</span> /usr/bin/stress m1:/usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器，查看</span></span><br><span class="line">[root@docker01 ~]#  docker <span class="built_in">exec</span> -it m1 /bin/bash</span><br><span class="line">[root@129d279404e7 /]# <span class="built_in">cat</span> /sys/fs/cgroup/memory/memory.limit_in_bytes </span><br><span class="line">268435456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 做压力测试，模拟占用1024MB的内存</span></span><br><span class="line">[root@129d279404e7 /]# stress  --vm-bytes 1024M --vm-keep -m 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存是否超过256M，始终在256M，没达到1024M</span></span><br><span class="line">[root@docker01 ~]# docker stats</span><br></pre></td></tr></table></figure>

<p>​	新项目一般先不做内存限制，跑一段时间，后期看情况再做内存限制。假如公司总访问量是100w次，按照110w的量做压力测试，内存设置为512M，如果高于70%-80%左右，可能有存在被黑客攻击的可能。一般是先做压力测试，按照使用情况多分配10%左右</p>
<p>​	常用压力测试命令：ab，stress，jmeter（专业测试工具）</p>
<hr>
<h3 id="2-3docker运行容器限制磁盘I-O"><a href="#2-3docker运行容器限制磁盘I-O" class="headerlink" title="2.3	docker运行容器限制磁盘I&#x2F;O"></a>2.3	docker运行容器限制磁盘I&#x2F;O</h3><p>​	磁盘I&#x2F;O：指的是计算机系统中磁盘和其他设备之间数据的读取和写入操作。I&#x2F;O速度的快慢对系统性能有很大影响，在数据库、Web服务器等通常需要对磁盘I&#x2F;O进行限制和优化，以此保证系统的稳定和高效（不易优化）。</p>
<hr>
<p>​	磁盘和内存的对比分析：</p>
<p>​	磁盘和内存都是计算机存储数据的设备，但是它们的作用和特点不同。</p>
<p>​	内存是计算机中的临时存储器件，用于存储正在运行的程序、操作系统和其他应用程序所需的数据。它的特点是速度快，但存储容量比较小，且不具备数据持久化能力，其当电源关闭时，内存中的数据就会丢失。</p>
<p>​	磁盘是计算机中的永久存储器件，用于存储长期保存的数据，如操作系统、应用程序、文档、图片、音频、视频文件等。它的特点是存储容量比较大，但速度比较慢，且可以实现数据持久化，即使电源关闭，磁盘中的数据也能保存下来。</p>
<hr>
<p>​	为什么要对磁盘IO做限制?</p>
<p>​	对磁盘IO做限制是为了防止过多的IO请求导致磁盘性能下降，甚至是宕机。当多个进程或容器同时访问磁盘时，如果没有限制磁盘IO，可能会导致IO瓶颈，使得磁盘无法承受过多的请求，从而降低系统的整体性能。</p>
<p>​	通过限制容器的磁盘IO，可以保证每一个容器在一定程度上独享磁盘IO资源，避免容器之间的竞争和影响。同时，限制磁盘IO也可以避免恶意容器滥用系统资源，对系统的稳定性和安全性造成影响。</p>
<p>​	举个例子，如果一个应用程序或容器，在短时间内对磁盘资源进行了大量的读写操作，那么可能会导致其他应用程序或容器无法及时访问磁盘资源，进而影响系统整体的性能和稳定性。<strong>旧版本可用，新版本这种方法不能使用</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制容器向指定设备写入的字节数/s，表示限制从/dev/sda设备读取的速率是1024字节/s，可选单位有B、K、M、G</span></span><br><span class="line">[root@docker01 ~]# docker run  --device-write-bps=/dev/sda:1024 value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制容器向指定设备读取的字节数/s</span></span><br><span class="line">[root@docker01 ~]# docker run  --device-read--bps value</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	例1：限制容器实例对硬盘的最高写入速度设置为1MB&#x2F;s<strong>新版本方法</strong></p>
<p>​	假设我们要创建一个名为my-app的docker容器，并将其对磁盘的这个写入速度都限制为1MB&#x2F;s，可以通过在容器运行时使用–device参数挂载磁盘设备，并通过–device-write-bps参数限制写入速度实现，具体操作步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">[root@docker01 ~]# <span class="built_in">mkdir</span> my-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个输出是tmpfs，我们必须切换成cgroup2fs才能生效</span></span><br><span class="line">[root@docker01 ~]# <span class="built_in">stat</span> -<span class="built_in">fc</span> %T /sys/fs/cgroup</span><br><span class="line">tmpfs	</span><br><span class="line">[root@docker01 ~]# </span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到cgroup v2，修改GRUB</span></span><br><span class="line">[root@docker01 ~]# vim /etc/default/grub</span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;crashkernel=auto resume=/dev/mapper/rl_192-swap rd.lvm.lv=rl_192/root rd.lvm.lv=rl_192/swap systemd.unified_cgroup_hierarchy=1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 grub 配置并重启,就能看到cgroup2fs说明成功</span></span><br><span class="line">[root@docker01 ~]# grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">[root@docker01 ~]# reboot</span><br><span class="line">[root@docker01 ~]# <span class="built_in">stat</span> -<span class="built_in">fc</span> %T /sys/fs/cgroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个新的docker容器，将my-app目录挂载到容器的/data目录，并将写入速度限制为1MB/s，</span></span><br><span class="line">[root@docker01 ~]# docker run -d --name my-data -v /root/data:/data rockylinux:8.8 <span class="built_in">sleep</span> infinity</span><br><span class="line">[root@docker01 ~]# CID=my-data</span><br><span class="line">[root@docker01 ~]# PID=$(docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> <span class="variable">$CID</span>)</span><br><span class="line">[root@docker01 ~]# CG=$(sed <span class="string">&#x27;s/0:://&#x27;</span> /proc/<span class="variable">$PID</span>/cgroup)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 NVMe 写入限速 1MB/s</span></span><br><span class="line">[root@docker01 ~]# <span class="built_in">echo</span> <span class="string">&quot;259:0 wbps=1048576&quot;</span> &gt; /sys/fs/cgroup<span class="variable">$CG</span>/io.max</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker容器测写入速度</span></span><br><span class="line">[root@6e7cfeab08de /]# docker <span class="built_in">exec</span> -it my-data bash</span><br><span class="line">[root@6e7cfeab08de /]# <span class="built_in">cd</span> /data</span><br><span class="line">[root@6e7cfeab08de data]# <span class="keyword">time</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=test.out bs=1M count=50 oflag=direct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测读取速度</span></span><br><span class="line">[root@6e7cfeab08de data]# <span class="built_in">dd</span> <span class="keyword">if</span>=/testfile of=/dev/null bs=1M count=1000 iflag=direct</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-docker实战-创建私有镜像仓库和加密认"><a href="#3-docker实战-创建私有镜像仓库和加密认" class="headerlink" title="3.docker实战 -创建私有镜像仓库和加密认"></a>3.docker实战 -创建私有镜像仓库和加密认</h2><h3 id="3-1-docker私有化仓库介绍"><a href="#3-1-docker私有化仓库介绍" class="headerlink" title="3.1 docker私有化仓库介绍"></a>3.1 docker私有化仓库介绍</h3><p>​	私有镜像仓库搭建教程</p>
<p>​	私有镜像仓库优点：速度快，安全，维护方便</p>
<p>​	使用docker思路：直接下载并使用registry镜像（无UI界面）启动docker实例</p>
<hr>
<p>​	实验环境规划</p>
<p>​	docker私有仓库地址：docker02，内存至少2g，IP：192.168.10.135，docker02，下面是前置工作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置主机名</span></span><br><span class="line">[root@localhost ~]# hostnamectl set-hostname docker02</span><br><span class="line">[root@localhost ~]# bash</span><br><span class="line">[root@docker02 ~]# </span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭selinux，永久禁用</span></span><br><span class="line">[root@docker02 ~]# sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;</span> /etc/selinux/config </span><br><span class="line">[root@docker02 ~]# reboot</span><br><span class="line">[root@docker02 ~]# getenforce</span><br><span class="line">[root@docker02 ~]# vim /etc/hosts</span><br><span class="line">192.168.10.134 docker01</span><br><span class="line">192.168.10.135 docker02</span><br><span class="line">[root@docker02 ~]# systemctl stop firewalld &amp;&amp; systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">[root@docker02 ~]# yum -y install chrony</span><br><span class="line">[root@docker02 ~]# systemctl  <span class="built_in">enable</span> chronyd --now</span><br><span class="line">[root@docker01 ~]# vim /etc/chrony.conf </span><br><span class="line"><span class="comment"># 文件最后增加如下内容</span></span><br><span class="line">server ntp1.aliyun.com iburst</span><br><span class="line">server ntp2.aliyun.com iburst</span><br><span class="line">server ntp1.tencent.com iburst</span><br><span class="line">server ntp2.tencent.com iburst</span><br><span class="line"></span><br><span class="line">[root@docker01 ~]# systemctl restart chronyd</span><br><span class="line">[root@docker01 ~]# <span class="built_in">date</span></span><br><span class="line">[root@docker02 ~]# crontab -e</span><br><span class="line">* * * * * /usr/bin/systemctl restart chronyd</span><br><span class="line">[root@docker02 ~]# systemctl restart crond</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装docker</span></span><br><span class="line">[root@docker02 ~]# yum install -y  yum-utils</span><br><span class="line">[root@docker02 ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">[root@docker02 ~]# yum install -y wget net-tools nfs-utils gcc gcc-c++ make cmake libxml2-devel openssl-devel curl curl-devel unzip <span class="built_in">sudo</span> libaio-devel ncurses-devel autoconf automake zlib-devel epel-release openssh-server socat ipvsadm conntrack-tools</span><br><span class="line">[root@docker02 ~]# yum install -y containerd.io-1.6.31-3.1.el8</span><br><span class="line">[root@docker02 ~]# yum install -y docker-ce</span><br><span class="line">[root@docker02 ~]# systemctl start docker &amp;&amp; systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本号</span></span><br><span class="line">[root@docker02 ~]# docker -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启包转发功能和修改内核参数</span></span><br><span class="line">[root@docker02 ~]# modprobe br_netfilter </span><br><span class="line">[root@docker02 ~]# <span class="built_in">cat</span> &gt; /etc/sysctl.d/docker.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">[root@docker02 ~]# sysctl -p /etc/sysctl.d/docker.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">[root@docker02 ~]# systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置镜像加速，创建或覆盖配置文件</span></span><br><span class="line">[root@docker02 ~]# <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://docker-0.unsee.tech&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker-cf.registry.cyou&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.1panel.live&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker服务使配置生效</span></span><br><span class="line">[root@docker02 ~]# <span class="built_in">sudo</span> systemctl daemon-reload &amp;&amp; <span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>​	docker01</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# vim /etc/hosts</span><br><span class="line">192.168.10.134 docker01</span><br><span class="line">192.168.10.135 docker02</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-使用registry搭建docker私有仓库"><a href="#3-2-使用registry搭建docker私有仓库" class="headerlink" title="3.2 使用registry搭建docker私有仓库"></a>3.2 使用registry搭建docker私有仓库</h3><p>​	docker01</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许 Docker 通过 HTTP（非 HTTPS）协议连接到指定的私有镜像仓库</span></span><br><span class="line">[root@docker01 ~]# vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://docker-0.unsee.tech&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker-cf.registry.cyou&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.1panel.live&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;insecure-registries&quot;</span>:[ <span class="string">&quot;192.168.10.135:5000&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">[root@docker01 ~]# systemctl restart docker</span><br><span class="line">[root@docker01 ~]# docker pull busybox:latest</span><br><span class="line">[root@docker01 ~]# docker tag busybox:latest 192.168.10.135:5000/busybox:v1	 <span class="comment">#给镜像打标签（重命名）</span></span><br><span class="line">[root@docker01 ~]# docker push 192.168.10.135:5000/busybox:v1  	<span class="comment">#推送到私有仓库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">[root@docker01 ~]# docker rmi -f 192.168.10.135:5000/busybox:v1 </span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	docker02</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉去registry并启动</span></span><br><span class="line">[root@docker02 ~]# docker pull registry:latest</span><br><span class="line">[root@docker02 ~]# docker run -d --name registry -p 5000:5000 -v /opt/registry:/var/lib/registry registry:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否启动成功</span></span><br><span class="line">[root@docker02 ~]# curl http://192.168.10.135:5000/v2/_catalog</span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[]&#125;</span><br><span class="line">[root@docker02 ~]# yum install tree -y</span><br><span class="line"><span class="comment"># 默认是空的</span></span><br><span class="line">[root@docker02 ~]# tree /opt/registry/</span><br><span class="line">/opt/registry/</span><br><span class="line">0 directories, 0 files</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="3-3-实战：使用harbor搭建-docker私有仓库"><a href="#3-3-实战：使用harbor搭建-docker私有仓库" class="headerlink" title="3.3 实战：使用harbor搭建 docker私有仓库"></a>3.3 实战：使用harbor搭建 docker私有仓库</h3><p>​	为harbor自签发证书，openssl能延长证书</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必须先删除registry，否则会引起报错（端口等）</span></span><br><span class="line">[root@docker02 ~]# docker <span class="built_in">rm</span> -f registry </span><br><span class="line">[root@docker02 ~]# <span class="built_in">mkdir</span> /data/ssl -p</span><br><span class="line">[root@docker02 ~]# <span class="built_in">cd</span> /data/ssl/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成ca证书</span></span><br><span class="line">[root@docker02 ssl]# openssl genrsa -out ca.key 3072</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个数字证书 ca.pem，3650表示证书的有效时间是10年，按照箭头提示填写，没有箭头标注的为空</span></span><br><span class="line">[root@docker02 ssl]# openssl req -new -x509 -days 3650 -key ca.key -out ca.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成域名的证书</span></span><br><span class="line">[root@docker02 ssl]# openssl genrsa -out harbor.key 3072</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个3072位的key，也就是私钥</span></span><br><span class="line">[root@docker02 ssl]# openssl req -new -key harbor.key -out harbor.csr</span><br><span class="line">[root@docker02 ssl]# openssl x509 -req -<span class="keyword">in</span> harbor.csr -CA ca.pem -CAkey ca.key -CAcreateserial -out harbor.pem -days 3650</span><br><span class="line"><span class="comment"># 一共6个文件</span></span><br></pre></td></tr></table></figure>

<hr>
<p>​	安装<a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor/releases/download/v2.3.0-rc3/harbor-offline-installer-v2.3.0-rc3.tgz%EF%BC%8C">harbor下载</a></p>
<p>​	<a target="_blank" rel="noopener" href="https://github.com/docker/compose/releases/download/v2.29.2/docker-compose-linux-x86_64">docker-compose-linux-x86_64下载</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除之前registry容器，防止与安装harbor冲突，上传 docker-compose-linux-x86_64，重命名以及加上x权限</span></span><br><span class="line">[root@docker02 ~]# docker <span class="built_in">rm</span> -f registry </span><br><span class="line">[root@docker02 ~]# <span class="built_in">mv</span> docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br><span class="line">[root@docker02 ~]# <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class="line">[root@docker02 ~]# <span class="built_in">mkdir</span> /data/install -p</span><br><span class="line">[root@docker02 ~]# <span class="built_in">cd</span> /data/install/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传下载好的harbor离线包并解压</span></span><br><span class="line">[root@docker02 install]# tar zxvf harbor-offline-installer-v2.3.0-rc3.tgz </span><br><span class="line">[root@docker02 install]# <span class="built_in">cd</span> harbor/</span><br><span class="line">[root@docker02 harbor]# <span class="built_in">cp</span> harbor.yml.tmpl harbor.yml</span><br><span class="line">[root@docker02 harbor]# vim harbor.yml</span><br><span class="line">hostname: docker02	<span class="comment"># 第5行</span></span><br><span class="line">  certificate: /data/ssl/harbor.pem	<span class="comment"># 第17行</span></span><br><span class="line">  private_key: /data/ssl/harbor.key <span class="comment"># 第18行</span></span><br><span class="line">[root@docker02 harbor]# ./install.sh 	<span class="comment"># 未报错，安装成功</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	在自己电脑上修改hosts文件，路径C:\Windows\System32\drivers\etc，增加下面这行</p>
<p>​	192.168.10.135	docker02</p>
<p>​	主机访问<a target="_blank" rel="noopener" href="https://docker02,默认账户密码admin,harbor12345,在harbor.yml有/">https://docker02，默认账户密码admin，Harbor12345，在harbor.yml有</a></p>
<p>​	扩展：harbor关闭与启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">[root@docker02 ~]# <span class="built_in">cd</span> /data/install/harbor</span><br><span class="line">[root@docker02 harbor]# docker-compose stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">[root@docker02 ~]# <span class="built_in">cd</span> /data/install/harbor</span><br><span class="line">[root@docker02 harbor]# docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果docker-compose up -d启动harbor之后，还是访问不了，则需要重启虚拟机</span></span><br></pre></td></tr></table></figure>

<hr>
<p>​	在docker01上测试使用docker02的harbor镜像仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改docker配置</span></span><br><span class="line">[root@docker01 ~]# vim /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://docker-0.unsee.tech&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker-cf.registry.cyou&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.1panel.live&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;insecure-registries&quot;</span>:[ <span class="string">&quot;192.168.10.135&quot;</span> ]</span><br><span class="line">&#125;</span><br><span class="line">[root@docker01 ~]# systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">[root@docker01 ~]# docker login 192.168.10.135</span><br><span class="line">Username: admin</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted <span class="keyword">in</span> /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给测试镜像tomcat8打标签，推送，然后就能 在https://docker02看见了，默认路径library修改为test</span></span><br><span class="line">[root@docker01 ~]# docker tag docker01/tomcat8:v2 192.168.10.135/test/tomcat8:v2</span><br><span class="line">[root@docker01 ~]# docker push 192.168.10.135/test/tomcat8:v2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-使用阿里云私有仓库存储自己的docker镜像"><a href="#3-4-使用阿里云私有仓库存储自己的docker镜像" class="headerlink" title="3.4 使用阿里云私有仓库存储自己的docker镜像"></a>3.4 使用阿里云私有仓库存储自己的docker镜像</h3><p>访问<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/ap-southeast-1/instance/dashboard">容器镜像服务</a></p>
<p>注册登录阿里云平台，创建命名空间，镜像仓库（选择本地部署），参考镜像仓库的基本信息来推送到阿里云私有仓库</p>
<hr>
<h2 id="4、docker静态IP和持久化-containerd和podman容器的安装和使用"><a href="#4、docker静态IP和持久化-containerd和podman容器的安装和使用" class="headerlink" title="4、docker静态IP和持久化-containerd和podman容器的安装和使用"></a>4、docker静态IP和持久化-containerd和podman容器的安装和使用</h2><h3 id="4-1创建docker容器指定不同的网络模式"><a href="#4-1创建docker容器指定不同的网络模式" class="headerlink" title="4.1	创建docker容器指定不同的网络模式"></a>4.1	创建docker容器指定不同的网络模式</h3><p>​	docker 的网络模式(<strong>面试频率较高</strong>)</p>
<p>​	Host模式，使用–net&#x3D;host指定，容器使用主机的IP和端口来进行通信，这样可以达到和主机一样的网络性能和配置，但是也存在安全风险。使用host模式时，容器不会创建自己的网络命名空间，也不会为容器单独分配IP地址，而是直接使用主机的IP地址和端口。因此容器之间的网络隔离会被打破，容器可以直接访问主机上所有的端口和服务，也可以被主机上的其他设备访问到。<strong>host网络模式一般用于需要直接访问主机资源的场景，例如主机上运行的服务需要直接访问容器中的服务。</strong></p>
<p>​	none模式，使用–net&#x3D;none指定。none网络模式就是不给容器分配任何网络资源，也就是说，容器不会创建虚拟网卡、IP地址和路由等网络资源，容器之间无法直接通信，也无法与外主机和外部网络进行通信。使用none网络模式时，容器只能使用本地文件系统和进程空间等资源。none网络模式一般用于特输场景，例如，需要在容器中进行一些本地操作，但是又不需要使用网络资源的情况下，或者是需要创建一个完全隔离的容器时。</p>
<p>​	bridge模式，使用–net&#x3D;bridge指定。这是docker默认的网络模式，在docker中，bridge网络模式就像一座桥，它通过一个虚拟网桥来连接多个容器。这是虚拟网桥就像一座桥梁，把连接到它上面的容器连接起来，这样他们就可以相互通信了。与外部网络进行通信时，虚拟网桥通过物理网卡连接到主机上的网络。</p>
<p>​	container模式，docker网络container模式是指创建容器的时候，通过–net container参数，指定其他已经存在某个容器共享一个network namespace，两个容器的进程通过lo网卡设备通信</p>
<hr>
<p>​	使用none模式启动一个docker实例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以none模式，使用--net=none启动一个容器，并且开启docker特权模式</span></span><br><span class="line">[root@docker01 ~]# docker run -itd --name none --net=none --privileged=<span class="literal">true</span> rockylinux:8.8 bash</span><br><span class="line">[root@docker01 ~]# docker <span class="built_in">exec</span> -it none bash</span><br><span class="line">[root@d7d819ffd3d5 /]# <span class="built_in">cat</span> /etc/hosts</span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line">[root@d7d819ffd3d5 /]# <span class="built_in">ls</span> /dev/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看挂载情况</span></span><br><span class="line">[root@d7d819ffd3d5 /]# mount -o <span class="built_in">bind</span> /etc /opt/</span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">overlay                   66G  6.7G   59G  11% /</span><br><span class="line">tmpfs                     64M     0   64M   0% /dev</span><br><span class="line">shm                       64M     0   64M   0% /dev/shm</span><br><span class="line">/dev/mapper/rl_192-root   66G  6.7G   59G  11% /etc/hosts</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<p>​	–privileged&#x3D;true：允许开启特权功能，使用这个参数会让docker容器拥有更高的权限，可以访问数主机的所有资源，就好像，如果你是普通的游客，你只能在景区指定的区域内走动，但如果你是景区的管理员，那么你就可以随意进出景区的各个区域，进行各种操作。</p>
<p>​	在docker中，运行特权容器的场景通常是需要执行一些底层操作，例如管理宿主机上的硬件设备，加载内核模块，访问系统的底层资源的。因此如果需要在容器中进行这些底层操作，就需要使用–privileged&#x3D;true参数。不过需要注意的是，这种高权限操作也可能存在安全风险，因此需要仔细考虑和控制风险。</p>
<p>​	特权模式通常用于需要访问宿主机底层设备或进行特殊操作的应用场景。例如：</p>
<p>1、需要在容器中执行内核模块加载或卸载操作。</p>
<p>2、需要访问系统中的设备节点，例如&#x2F;dev和&#x2F;sys目录下的文件。</p>
<p>3、需要访问系统的硬件资源，如CPU、内存、网络和存储设备等。</p>
<hr>
<p>未设置privileged启动的容器，<strong>通常都不挂在特权模式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -it rockylinux:8.8 bash</span><br><span class="line">[root@d7d819ffd3d5 /]# <span class="built_in">ls</span> /dev/		<span class="comment"># 可以看到的设备文件比较少</span></span><br><span class="line">[root@d7d819ffd3d5 /]# mount -o <span class="built_in">bind</span> /etc /opt/		<span class="comment"># 不可以挂载成功，mount命令执行失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mount -o bind是将一个目录挂载到另一个目录上，而不加-o bind的mount是将整个文件系统挂载到指定目录下</span></span><br></pre></td></tr></table></figure>

<hr>
<p> 共享宿主机网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run --name host -it --net=host --privileged=<span class="literal">true</span> rockylinux:8.8 bash</span><br><span class="line">[root@docker01 /]# <span class="built_in">cat</span> /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.10.134 docker01</span><br><span class="line">192.168.10.135 docker02</span><br><span class="line">[root@docker01 /]# <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<hr>
<p>和已经存在的none容器共享网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run --name container1 --net=container:none -it --privileged=<span class="literal">true</span> rockylinux:8.8 bash</span><br></pre></td></tr></table></figure>

<hr>
<p>创建桥接网络 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run --name bridge -it --privileged=<span class="literal">true</span> rockylinux:8.8 bash</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2docker容器数据持久化"><a href="#4-2docker容器数据持久化" class="headerlink" title="4.2	docker容器数据持久化"></a>4.2	docker容器数据持久化</h3><p>通过将宿主机的目录或文件挂载到容器内，实现容器数据的持久化存储，避免容器删除后数据丢失</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# <span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line">[root@docker01 ~]# <span class="built_in">cd</span> <span class="built_in">test</span>/</span><br><span class="line">[root@docker01 <span class="built_in">test</span>]# vim dockerfile </span><br><span class="line">FROM rockylinux:8.8</span><br><span class="line">VOLUME [<span class="string">&quot;/datavolume3&quot;</span>,<span class="string">&quot;/datavolume6&quot;</span>]</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="comment"># 基于当前目录做一个镜像</span></span><br><span class="line">[root@docker01 <span class="built_in">test</span>]# docker build -t=<span class="string">&quot;docker00/volume:v1&quot;</span> .</span><br><span class="line">[root@docker01 <span class="built_in">test</span>]# docker run -it --name volume -it xuegod/volume:v1</span><br><span class="line">[root@d7d819ffd3d5 /]# <span class="built_in">cd</span> /datavolume</span><br><span class="line"><span class="comment"># 会出现两个临时目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器volume的详细信息，找到与物理主机对于的详细目录</span></span><br><span class="line">[root@docker01 <span class="built_in">test</span>]# docker inspect volume</span><br><span class="line">[root@docker01 <span class="built_in">test</span>]# </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将物理机目录和容器目录挂载（可以指定多个），之后在容器里面创建目录，会在物理机上有存在</span></span><br><span class="line">[root@docker01 ~]# docker run --name volumev1 -it -v /datavolume3/:/datavolume3 docker/volume:v1 bash		<span class="comment"># -v就是维持数据持久化的命令，i交互式，d伪终端</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="4-3containerd容器概述"><a href="#4-3containerd容器概述" class="headerlink" title="4.3	containerd容器概述"></a>4.3	containerd容器概述</h3><p>​	containerd容容器介绍（专注于运行容器，不与docker冲突）</p>
<p>​	<a target="_blank" rel="noopener" href="https://containerd.io/">官方文档 </a>，containerd 是一个工业级标准的容器运行时，最初由docker 公司开发并贡献给 Cloud Native Computing Foundation (CNCF)。它提供以下核心容器管理功能：<strong>容器镜像的传输和存储，容器的执行和管理，容器的网络管理</strong>，相比 Docker，Containerd 更加轻量化和模块化，能够更好地与 Kubernetes 等容器编排系统集成。</p>
<p>​	从docker 1.11版本开始，Docker公司将Containerd从Docker中分离出来，并将其作为一个独立的开源项目提交给CNCF进行维护。这是因为Docker作为一个完整的容器平台，包含了很多不必要的功能，而且代码比较庞大，难以维护。<strong>containerd则是一个更加专注于容器管理的运行时，可以更好地满足云原生应用的需求。</strong></p>
<p>​	Containerd与 Docker Engine 的分离，也使得Docker公司能够专注于Docker Desktop、Docker·Hub等产品的开发和运营，而将容器运行时的开发和维护交给了CNCF社区。</p>
<p>​	Kubernetes 1.24 版本开始不再支持 Docker 的原因：<br>​	第一，Docker 的发展方向与 Kubernetes 不完全一致。Docker 更注重完整的容器生态系统，而 Kubernetes 更关注以容器为中心的编排与管理。<br>​	第二，Containerd 是一个工业级标准的容器运行时，它更轻量、性能更好、可用性更高，能够更好地与 Kubernetes 集成。<br>​	第三，Docker 不满足 Kubernetes 的 CRI（Container Runtime Interface） 规范，具体原因包括：</p>
<p>​	过于庞大，Docker 是一个功能丰富的软件包，包含许多 Kubernetes 并不需要的组件，导致部署和管理复杂，不利于轻量级容器运行。<br>​	API 不稳定，Docker 的 API 并非为 Kubernetes 设计，在 Kubernetes 环境中使用会出现 API 不稳定、兼容性问题及维护负担。<br>​	安全性问题，Docker 的安全模型并非针对 Kubernetes 环境设计，可能在 Kubernetes 中运行时引入不必要的安全风险。</p>
<hr>
<h3 id="4-4containerd命令行工具：ctr"><a href="#4-4containerd命令行工具：ctr" class="headerlink" title="4.4	containerd命令行工具：ctr"></a>4.4	containerd命令行工具：ctr</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">[root@docker01 ~]# yum install -y containerd.io-1.6.22 --allowerasing</span><br><span class="line">[root@docker01 containerd]# systemctl <span class="built_in">enable</span> containerd --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为需要换源，所以操作下面自行百度</span></span><br><span class="line"><span class="comment"># 从镜像仓库拉去镜像</span></span><br><span class="line">[root@docker01 ~]# ctr image pull docker.io/library/nginx:latest</span><br><span class="line"><span class="comment"># 列出所有镜像</span></span><br><span class="line">[root@docker01 ~]# ctr image <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 导出镜像</span></span><br><span class="line">[root@docker01 ~]# ctr image <span class="built_in">export</span> 镜像.tar.gz</span><br><span class="line"><span class="comment"># 解压镜像</span></span><br><span class="line">[root@docker01 ~]# ctr images import 镜像.tar.gz</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-5containerd使用harbor私有镜像仓库"><a href="#4-5containerd使用harbor私有镜像仓库" class="headerlink" title="4.5	containerd使用harbor私有镜像仓库"></a>4.5	containerd使用harbor私有镜像仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# vim /etc/containerd/config.toml</span><br><span class="line"><span class="comment"># 修改149行，添加harbor用户名和密码</span></span><br><span class="line"><span class="comment"># 找到158行，添加harbor的IP</span></span><br><span class="line">[root@docker01 ~]# systemctl restart containerd</span><br><span class="line"><span class="comment"># 从harbor拉去镜像，--skip-verify跳过https验证</span></span><br><span class="line">[root@docker01 ~]# ctr images pull 192.168.10.135/test/tomcat:v1 --skip-verify --user admin:Harbor12345</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-6podman容器概述"><a href="#4-6podman容器概述" class="headerlink" title="4.6	podman容器概述"></a>4.6	podman容器概述</h3><p>​	podman容器介绍</p>
<p>​	Podman是一种用于管理和运行容器的工具，类似于Docker。它可以帮助你在Linux系统上创建、管理和运行容器，让你的应用程序更加轻便和可移植。与Docker相比，Podman提供了更强的隔离和安全性，支持在非特权用户下运行容器，并提供与Docker CLI兼容的命令行接口，让Docker用户可以很容易地使用Podman。Podman可以通过简单的命令行操作来启动、停止和检查容器状态，并支持使用Dockerfile来构建容器镜像。总的来说，Podman是一个强大而灵活的工具，可以帮助你更方便地管理和部署容器化应用程序。</p>
<p>与 Docker相比，Podman具有以下一些不同之处：<br>	1、Podman不需要运行Docker守护程序，因此可以在不同的Linux主机上运行，从而提高了可移植性。<br>	2、Podman容器不需要特权用户或管理员权限即可运行，这使得非特权用户可以在Linux系统上运行容器，从而提高了安全性。<br>	3、Podman CLI与Docker CLI兼容，因此Docker用户可以很容易地转换到Podman容器环境中。</p>
<p>使用Podman之后我们不需要管理和Docker守护进程一样的守护进程，Podman也同样支持<br>Docker命令，他们的镜像也是兼容的。</p>
<p><a target="_blank" rel="noopener" href="https://podman.io/">Podman官网</a>，<a target="_blank" rel="noopener" href="https://github.com/containers/libpod">Podman项目地址</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加上 --allowerasing：yum 会卸载冲突的包继续安装</span></span><br><span class="line">[root@docker01 ~]# [root@docker01 ~]# yum install -y podman --allowerasing</span><br><span class="line">[root@docker01 ~]# ps -ef |grep podman	<span class="comment"># 查找系统中所有与 podman 相关的进程</span></span><br><span class="line">[root@docker01 ~]# podman --<span class="built_in">help</span></span><br><span class="line">[root@docker01 ~]# podman info	<span class="comment"># 查看详细信息</span></span><br><span class="line">[root@docker01 ~]# podman pull busybox	<span class="comment"># 拉去镜像</span></span><br><span class="line">[root@docker01 ~]# podman images	<span class="comment">#查看拉去的镜像</span></span><br><span class="line">[root@docker01 ~]# podman tag busybox busybox:v1	<span class="comment">#打标签</span></span><br><span class="line">[root@docker01 ~]# podman run busybox <span class="comment"># 运行容器</span></span><br><span class="line">[root@docker01 ~]# podman run busybox -it sh	<span class="comment"># 进入容器</span></span><br><span class="line"><span class="comment"># 以后台方式运行一个名为 nginx-v1 的 Nginx 容器</span></span><br><span class="line">[root@docker01 ~]# podman run -d --name nginx-v1 -p 9090:80 --restart=always nginx</span><br><span class="line">[root@docker01 ~]# podman <span class="built_in">rm</span> -f nginx:v1	<span class="comment"># 删除容器</span></span><br></pre></td></tr></table></figure>



<p>​	设置Podman容器实例开机自动启动</p>
<p>​	因为podman没有守护进程，所以提供了生成systemd启动脚本的方法。让我们可以使用systemctl来设置开机启动。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为web86的Nginx容器，主机通过86端口访问</span></span><br><span class="line">[root@docker01 ~]# podman run -d -p 86:80 --name web86 nginx</span><br><span class="line">[root@docker01 ~]# <span class="built_in">cd</span> /usr/lib/systemd/system</span><br><span class="line"><span class="comment"># 为web86容器生成systemd服务配置文件</span></span><br><span class="line">[root@docker01 system]# podman generate systemd --name web86 --files</span><br><span class="line">[root@docker01 system]# systemctl <span class="built_in">enable</span> container-web86.service</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://geeeemi.github.io">Geeeemi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://geeeemi.github.io/2025/12/23/RockyLinux8.8%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A8%E6%A0%88%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8EDocker%E5%88%B0Containerd/">https://geeeemi.github.io/2025/12/23/RockyLinux8.8%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A8%E6%A0%88%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8EDocker%E5%88%B0Containerd/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://geeeemi.github.io" target="_blank">Geeeemi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/Containerd/">Containerd</a><a class="post-meta__tags" href="/tags/Podman/">Podman</a><a class="post-meta__tags" href="/tags/RockyLinux8-8/">RockyLinux8.8</a><a class="post-meta__tags" href="/tags/%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/">私有镜像仓库</a><a class="post-meta__tags" href="/tags/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98/">容器实战</a><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4%E6%8C%87%E5%8D%97/">运维指南</a><a class="post-meta__tags" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a><a class="post-meta__tags" href="/tags/DevOps/">DevOps</a><a class="post-meta__tags" href="/tags/Harbor/">Harbor</a><a class="post-meta__tags" href="/tags/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/">容器网络</a><a class="post-meta__tags" href="/tags/%E8%B5%84%E6%BA%90%E9%85%8D%E9%A2%9D/">资源配额</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/14.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/27/kubernetes%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB-%E6%9E%B6%E6%9E%84-%E7%BB%84%E4%BB%B6-%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/" title="kubernetes深度解读-架构-组件-资源对象"><img class="cover" src="/img/cover/13.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">kubernetes深度解读-架构-组件-资源对象</div></div><div class="info-2"><div class="info-item-1">1、Kubernetes概述​	kubernetes的github地址  ​	官方站点，来源于Google的borg项目，3个月左右更新一次 ​	kubernetes是一个可移植、可以扩展的开源容器管理平台，简称k8s ​	可扩展：安装k8s的物理节点可以根据业务规模动态扩缩容，k8s中的pod应用也可以实现自动扩容缩，资源可以扩展，CRD自定义资源  ​	kubernetes提供了应用程序的快速部署、升级和回滚能力，利用service（四层代理）可以实现服务注册、发现，通过kube-proxy可以实现负载均衡，通过coredns可实现域名解析，通过ingress-controller可以实现七层负载均衡等功能。 ​	可以对pod自动化部署，自动化扩缩容，跨主机管理等。k8s部署服务，都是封装到pod里的，这个pod自动扩缩容很有必要。 ​	可以对代码进行灰度发布、金丝雀发布、蓝绿发布、滚动更新等。 ​	具有完整的监控系统和日志收集平台，具有恢复自恢复的能力。  ​	相关岗位：云原生、docker、容器、k8s、kubernetes、devops、架构师。 ​	kubernete...</div></div></div></a><a class="pagination-related" href="/2025/12/15/%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/" title="Linux全局代理上网配置指南：以CentOS系列为例"><img class="cover" src="/img/cover/12.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux全局代理上网配置指南：以CentOS系列为例</div></div><div class="info-2"><div class="info-item-1">  修改environment文件123vim /etc/environmenthttp_proxy=&quot;http://192.168.10.1:10808&quot;https_proxy=&quot;http://192.168.10.1:10808&quot;  设置立即生效1source /etc/environment  修改 Shell 配置文件12echo &#x27;export http_proxy=&quot;http://192.168.10.1:10808&quot;&#x27; &gt;&gt; ~/.bashrcecho &#x27;export https_proxy=&quot;http://192.168.10.1:10808&quot;&#x27; &gt;&gt; ~/.bashrc  设置立即生效1source ~/.bashrc  配置yum代理12vim /etc/yum.confproxy=http://192.168.10.1:10808  配置Wget代理1echo &#x27;https_proxy = http://1...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/12/27/kubernetes%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB-%E6%9E%B6%E6%9E%84-%E7%BB%84%E4%BB%B6-%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/" title="kubernetes深度解读-架构-组件-资源对象"><img class="cover" src="/img/cover/13.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-27</div><div class="info-item-2">kubernetes深度解读-架构-组件-资源对象</div></div><div class="info-2"><div class="info-item-1">1、Kubernetes概述​	kubernetes的github地址  ​	官方站点，来源于Google的borg项目，3个月左右更新一次 ​	kubernetes是一个可移植、可以扩展的开源容器管理平台，简称k8s ​	可扩展：安装k8s的物理节点可以根据业务规模动态扩缩容，k8s中的pod应用也可以实现自动扩容缩，资源可以扩展，CRD自定义资源  ​	kubernetes提供了应用程序的快速部署、升级和回滚能力，利用service（四层代理）可以实现服务注册、发现，通过kube-proxy可以实现负载均衡，通过coredns可实现域名解析，通过ingress-controller可以实现七层负载均衡等功能。 ​	可以对pod自动化部署，自动化扩缩容，跨主机管理等。k8s部署服务，都是封装到pod里的，这个pod自动扩缩容很有必要。 ​	可以对代码进行灰度发布、金丝雀发布、蓝绿发布、滚动更新等。 ​	具有完整的监控系统和日志收集平台，具有恢复自恢复的能力。  ​	相关岗位：云原生、docker、容器、k8s、kubernetes、devops、架构师。 ​	kubernete...</div></div></div></a><a class="pagination-related" href="/2025/12/30/%E4%BD%BF%E7%94%A8Kubeadm%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E5%8D%95master%E8%8A%82%E7%82%B9k8s%E9%9B%86%E7%BE%A4%EF%BC%88%E4%B8%80%EF%BC%89/" title="使用Kubeadm搭建生产环境的单Master节点K8s集群（一）"><img class="cover" src="/img/cover/15.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-30</div><div class="info-item-2">使用Kubeadm搭建生产环境的单Master节点K8s集群（一）</div></div><div class="info-2"><div class="info-item-1">1、	Kubernetes简介​	准备三台linux机器，配置如下，硬盘均为100G    IP 主机名 角色 内存 CPU    192.168.10.140(静态) k8s01 master 4G 4 vCPU   192.168.10.141(静态) k8s02 worker 4G（2G也可以） 4 vCPU   192.168.10.142(静态) k8s03 worker 4G（2G也可以） 4 vCPU    ​	三台机器均进行如下操作（初始化阶段） ​	安装k8s初始化集群：物理机网段、Pod网段、service网段不能冲突 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Geeeemi</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Geeeemi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Geeeemi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yaka6875@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客，有问题邮箱联系我</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85docker%E5%AE%B9%E5%99%A8%E5%B9%B6%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="toc-number">1.</span> <span class="toc-text">1.安装docker容器并配置镜像加速</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 实验环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-docker%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-%E6%93%8D%E4%BD%9C%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 docker基本用法-操作镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%80%9A%E8%BF%87docker%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 通过docker部署应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E5%9F%BA%E4%BA%8Edockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">1.4.</span> <span class="toc-text">1.4基于dockerfile构建镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81docker%E5%AE%9E%E6%88%98-dockerfile%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%95%9C%E5%83%8F%E5%92%8C%E8%B5%84%E6%BA%90%E9%85%8D%E9%A2%9D"><span class="toc-number">2.</span> <span class="toc-text">2、docker实战-dockerfile构建企业级镜像和资源配额</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%981%EF%BC%9Adocker%E6%9E%84%E5%BB%BAnginx%E9%95%9C%E5%83%8F%E2%80%94%E9%83%A8%E7%BD%B2nginx%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99"><span class="toc-number">2.1.</span> <span class="toc-text">实战1：docker构建nginx镜像—部署nginx静态网站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%982%EF%BC%9Adocker%E6%9E%84%E5%BB%BAtomcat%E9%95%9C%E5%83%8F"><span class="toc-number">2.2.</span> <span class="toc-text">实战2：docker构建tomcat镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%983%EF%BC%9Adocker%E6%9E%84%E5%BB%BAapache%E9%95%9C%E5%83%8F"><span class="toc-number">2.3.</span> <span class="toc-text">实战3：docker构建apache镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-docker%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E9%99%90%E5%88%B6CPU"><span class="toc-number">2.4.</span> <span class="toc-text">2.1 docker运行容器限制CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2docker%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E9%99%90%E5%88%B6%E5%86%85%E5%AD%98"><span class="toc-number">2.5.</span> <span class="toc-text">2.2	docker运行容器限制内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3docker%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E9%99%90%E5%88%B6%E7%A3%81%E7%9B%98I-O"><span class="toc-number">2.6.</span> <span class="toc-text">2.3	docker运行容器限制磁盘I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-docker%E5%AE%9E%E6%88%98-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%92%8C%E5%8A%A0%E5%AF%86%E8%AE%A4"><span class="toc-number">3.</span> <span class="toc-text">3.docker实战 -创建私有镜像仓库和加密认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-docker%E7%A7%81%E6%9C%89%E5%8C%96%E4%BB%93%E5%BA%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 docker私有化仓库介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8registry%E6%90%AD%E5%BB%BAdocker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 使用registry搭建docker私有仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BD%BF%E7%94%A8harbor%E6%90%AD%E5%BB%BA-docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 实战：使用harbor搭建 docker私有仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%AD%98%E5%82%A8%E8%87%AA%E5%B7%B1%E7%9A%84docker%E9%95%9C%E5%83%8F"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 使用阿里云私有仓库存储自己的docker镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81docker%E9%9D%99%E6%80%81IP%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96-containerd%E5%92%8Cpodman%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">4、docker静态IP和持久化-containerd和podman容器的安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E5%88%9B%E5%BB%BAdocker%E5%AE%B9%E5%99%A8%E6%8C%87%E5%AE%9A%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">4.1	创建docker容器指定不同的网络模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">4.2	docker容器数据持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3containerd%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">4.3.</span> <span class="toc-text">4.3	containerd容器概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4containerd%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%EF%BC%9Actr"><span class="toc-number">4.4.</span> <span class="toc-text">4.4	containerd命令行工具：ctr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5containerd%E4%BD%BF%E7%94%A8harbor%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">4.5.</span> <span class="toc-text">4.5	containerd使用harbor私有镜像仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6podman%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">4.6.</span> <span class="toc-text">4.6	podman容器概述</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/30/%E4%BD%BF%E7%94%A8Kubeadm%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E5%8D%95master%E8%8A%82%E7%82%B9k8s%E9%9B%86%E7%BE%A4%EF%BC%88%E4%B8%80%EF%BC%89/" title="使用Kubeadm搭建生产环境的单Master节点K8s集群（一）"><img src="/img/cover/15.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用Kubeadm搭建生产环境的单Master节点K8s集群（一）"/></a><div class="content"><a class="title" href="/2025/12/30/%E4%BD%BF%E7%94%A8Kubeadm%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E5%8D%95master%E8%8A%82%E7%82%B9k8s%E9%9B%86%E7%BE%A4%EF%BC%88%E4%B8%80%EF%BC%89/" title="使用Kubeadm搭建生产环境的单Master节点K8s集群（一）">使用Kubeadm搭建生产环境的单Master节点K8s集群（一）</a><time datetime="2025-12-30T11:41:00.000Z" title="发表于 2025-12-30 19:41:00">2025-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/27/kubernetes%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB-%E6%9E%B6%E6%9E%84-%E7%BB%84%E4%BB%B6-%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/" title="kubernetes深度解读-架构-组件-资源对象"><img src="/img/cover/13.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kubernetes深度解读-架构-组件-资源对象"/></a><div class="content"><a class="title" href="/2025/12/27/kubernetes%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB-%E6%9E%B6%E6%9E%84-%E7%BB%84%E4%BB%B6-%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/" title="kubernetes深度解读-架构-组件-资源对象">kubernetes深度解读-架构-组件-资源对象</a><time datetime="2025-12-27T12:50:00.000Z" title="发表于 2025-12-27 20:50:00">2025-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/23/RockyLinux8.8%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A8%E6%A0%88%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8EDocker%E5%88%B0Containerd/" title="RockyLinux8.8容器技术全栈实战：从Docker到Containerd"><img src="/img/cover/14.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RockyLinux8.8容器技术全栈实战：从Docker到Containerd"/></a><div class="content"><a class="title" href="/2025/12/23/RockyLinux8.8%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A8%E6%A0%88%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8EDocker%E5%88%B0Containerd/" title="RockyLinux8.8容器技术全栈实战：从Docker到Containerd">RockyLinux8.8容器技术全栈实战：从Docker到Containerd</a><time datetime="2025-12-23T12:50:00.000Z" title="发表于 2025-12-23 20:50:00">2025-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/15/%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/" title="Linux全局代理上网配置指南：以CentOS系列为例"><img src="/img/cover/12.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux全局代理上网配置指南：以CentOS系列为例"/></a><div class="content"><a class="title" href="/2025/12/15/%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/" title="Linux全局代理上网配置指南：以CentOS系列为例">Linux全局代理上网配置指南：以CentOS系列为例</a><time datetime="2025-12-15T02:12:00.000Z" title="发表于 2025-12-15 10:12:00">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/14.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Geeeemi</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/js/tw_cn.js?v=5.5.3"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>